/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.20 from the
 * contents of Croco.xs. Do not edit this file, edit Croco.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Croco.xs"
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "ppport.h"

#include <libcroco/libcroco.h>

#include "const-c.inc"

#line 21 "Croco.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

#line 64 "Croco.c"

XS(XS_CSS__Croco_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "class");
    {
	char*	class = (char *)SvPV_nolen(ST(0));
	CROMParser *	RETVAL;
#line 17 "Croco.xs"
        CROMParser *parser = NULL;
        parser = cr_om_parser_new(NULL);
        if ( !parser ) {
            die("Could not create parser");
        }
        RETVAL = parser;
#line 86 "Croco.c"
	ST(0) = sv_newmortal();
        sv_setref_pv(ST(0), class, (void*) RETVAL);
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco_parse); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco_parse)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "parser, string");
    {
	CROMParser *	parser;
	char*	string = (char *)SvPV_nolen(ST(1));
	CRStyleSheet *	RETVAL;

        if (sv_derived_from(ST(0), "CSS::Croco"))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            parser = INT2PTR(CROMParser *, tmp);
          }
        else
          croak("parser is not of type CSS::Croco");
#line 31 "Croco.xs"
        CRStyleSheet *stylesheet = NULL ;
        enum CRStatus status = cr_om_parser_parse_buf( parser, string, strlen( string ), CR_UTF_8, &stylesheet );
        if ( status == CR_OK ) {
            RETVAL = stylesheet;
        } else {
            die( "Died: %d", status ); 
        }
#line 124 "Croco.c"
	ST(0) = sv_newmortal();
        sv_setref_pv(ST(0), "CSS::Croco::StyleSheet", (void*) RETVAL);
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "parser");
    {
	CROMParser *	parser;

        if (sv_derived_from(ST(0), "CSS::Croco"))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            parser = INT2PTR(CROMParser *, tmp);
          }
        else
          croak("parser is not of type CSS::Croco");
#line 46 "Croco.xs"
        cr_om_parser_destroy( parser );
#line 154 "Croco.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_CSS__Croco__StyleSheet_to_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__StyleSheet_to_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "stylesheet");
    {
	CRStyleSheet *	stylesheet;
	char *	RETVAL;
	dXSTARG;

        if ( sv_derived_from(ST(0), "CSS::Croco::StyleSheet"))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            stylesheet = INT2PTR(CRStyleSheet *, tmp);
          }
        else
          croak("stylesheet is not of type CSS::Croco::StyleSheet");
#line 54 "Croco.xs"
        RETVAL = cr_stylesheet_to_string( stylesheet );
#line 184 "Croco.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__StyleSheet_rules); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__StyleSheet_rules)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "stylesheet");
    {
	CRStyleSheet *	stylesheet;
	AV *	RETVAL;

        if ( sv_derived_from(ST(0), "CSS::Croco::StyleSheet"))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            stylesheet = INT2PTR(CRStyleSheet *, tmp);
          }
        else
          croak("stylesheet is not of type CSS::Croco::StyleSheet");
#line 62 "Croco.xs"
        RETVAL = newAV();
        int i;
        int number_of_rules = cr_stylesheet_nr_rules( stylesheet );
        for ( i = 0; i < number_of_rules; i++ ) {
            CRStatement* statement = cr_stylesheet_statement_get_from_list( stylesheet, i );
            SV* rv = newSViv(0);
            char *class;
            char base[] = "CSS::Croco::Statement::";
            switch ( statement->type ) {
                case AT_RULE_STMT:
                    class = strdup("AtRule");
                    break;
                case RULESET_STMT:    
                    class = strdup("RuleSet");
                    break;
                case AT_IMPORT_RULE_STMT:
                    class = strdup("Import");
                    break;
                case AT_MEDIA_RULE_STMT: 
                    class = strdup("Media");
                    break;
                case AT_PAGE_RULE_STMT: 
                    class = strdup("Page");
                    break;
                case AT_CHARSET_RULE_STMT: 
                    class = strdup("Charset");
                    break;
                case AT_FONT_FACE_RULE_STMT:
                    class = strdup("FontFace");
                    break;
                default:
                    class = strdup("Unknown");
            }
            sv_setref_pv(rv, strcat(base,class), (void*) statement);
            av_push( RETVAL, rv );
        }
#line 249 "Croco.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__StyleSheet_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__StyleSheet_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "stylesheet");
    {
	CRStyleSheet *	stylesheet;

        if ( sv_derived_from(ST(0), "CSS::Croco::StyleSheet"))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            stylesheet = INT2PTR(CRStyleSheet *, tmp);
          }
        else
          croak("stylesheet is not of type CSS::Croco::StyleSheet");
#line 105 "Croco.xs"
        cr_stylesheet_destroy( stylesheet );
#line 279 "Croco.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_CSS__Croco__Statement_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__Statement_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "statement");
    {
	CRStatement *	statement;

        if (sv_derived_from(ST(0), "CSS::Croco::Statement"))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            statement = INT2PTR(CRStatement *, tmp);
          }
        else
          croak("statement is not of type CSS::Croco::Statement");
#line 113 "Croco.xs"
        cr_statement_destroy( statement );
#line 307 "Croco.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_CSS__Croco__Statement__RuleSet_get_declarations); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__Statement__RuleSet_get_declarations)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "statement");
    {
	CRStatement *	statement;
	SV *	RETVAL;

        if (sv_derived_from(ST(0), "CSS::Croco::Statement"))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            statement = INT2PTR(CRStatement *, tmp);
          }
        else
          croak("statement is not of type CSS::Croco::Statement");
#line 121 "Croco.xs"
        CRDeclaration* decl = NULL;
        RETVAL = newAV();
        cr_statement_ruleset_get_declarations(statement, &decl);
        int i;
        SV* rv = newSV(0);
        sv_setref_pv(rv, "CSS::Croco::DeclarationList", (void*) decl);
        RETVAL = rv;
#line 342 "Croco.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__Statement__RuleSet_parse_declaration); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__Statement__RuleSet_parse_declaration)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "statement, string");
    {
	CRStatement*	statement;
	char*	string = (char *)SvPV_nolen(ST(1));
	CRDeclaration *	RETVAL;

        if (sv_derived_from(ST(0), "CSS::Croco::Statement"))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            statement = INT2PTR(CRStatement *, tmp);
          }
        else
          croak("statement is not of type CSS::Croco::Statement");
#line 137 "Croco.xs"
        CRDeclaration* decl = NULL;
        decl = cr_declaration_parse_from_buf( statement, string, CR_UTF_8 );
        RETVAL = decl;
#line 376 "Croco.c"
	ST(0) = sv_newmortal();
        sv_setref_pv(ST(0), "CSS::Croco::Declaration", (void*) RETVAL);
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__DeclarationList_next); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__DeclarationList_next)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "declaration");
    {
	CRDeclaration *	declaration;
	CRDeclaration *	RETVAL;

        if ( sv_derived_from(ST(0), "CSS::Croco::Declaration") || sv_derived_from( ST(0),
            "CSS::Croco::DeclarationList" ))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            declaration = INT2PTR(CRDeclaration *, tmp);
          }
        else
          croak("declaration is not of type CSS::Croco::Declaration");
#line 149 "Croco.xs"
        RETVAL = declaration;
#line 408 "Croco.c"
	ST(0) = sv_newmortal();
        sv_setref_pv(ST(0), "CSS::Croco::Declaration", (void*) RETVAL);
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__DeclarationList_parse); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__DeclarationList_parse)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "class, string");
    {
	char*	class = (char *)SvPV_nolen(ST(0));
	char*	string = (char *)SvPV_nolen(ST(1));
	SV *	RETVAL;
#line 158 "Croco.xs"
        CRDeclaration* decl = NULL;
        decl = cr_declaration_parse_list_from_buf( string, CR_UTF_8 );
        SV* rv = newSV(0);
        sv_setref_pv(rv, class, (void*) decl);
        RETVAL = rv;
#line 436 "Croco.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__DeclarationList_property); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__DeclarationList_property)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "declaration, name");
    {
	CRDeclaration*	declaration;
	char*	name = (char *)SvPV_nolen(ST(1));
	SV *	RETVAL;

        if ( sv_derived_from(ST(0), "CSS::Croco::Declaration") || sv_derived_from( ST(0),
            "CSS::Croco::DeclarationList" ))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            declaration = INT2PTR(CRDeclaration *, tmp);
          }
        else
          croak("declaration is not of type CSS::Croco::Declaration");
#line 171 "Croco.xs"
        CRDeclaration* decl = cr_declaration_get_by_prop_name( declaration, name );
        SV* rv = newSV(0);
        sv_setref_pv(rv, "CSS::Croco::Declaration", (void*) decl);
        RETVAL = rv;
#line 472 "Croco.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__DeclarationList_to_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__DeclarationList_to_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "declaration, indent = 0");
    {
	CRDeclaration *	declaration;
	long	indent;
	char *	RETVAL;
	dXSTARG;

        if ( sv_derived_from(ST(0), "CSS::Croco::Declaration") || sv_derived_from( ST(0),
            "CSS::Croco::DeclarationList" ))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            declaration = INT2PTR(CRDeclaration *, tmp);
          }
        else
          croak("declaration is not of type CSS::Croco::Declaration");

	if (items < 2)
	    indent = 0;
	else {
	    indent = (long)SvIV(ST(1));
	}
#line 183 "Croco.xs"
        RETVAL = cr_declaration_list_to_string( declaration, indent );
#line 512 "Croco.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__DeclarationList_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__DeclarationList_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "declaration");
    {
	CRDeclaration*	declaration;

        if ( sv_derived_from(ST(0), "CSS::Croco::Declaration") || sv_derived_from( ST(0),
            "CSS::Croco::DeclarationList" ))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            declaration = INT2PTR(CRDeclaration *, tmp);
          }
        else
          croak("declaration is not of type CSS::Croco::Declaration");
#line 191 "Croco.xs"
//        TODO
//        cr_declaration_destroy( declaration );
#line 543 "Croco.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_CSS__Croco__Declaration_property); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__Declaration_property)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "declaration, value = NULL");
    {
	CRDeclaration *	declaration;
	char*	value;
	char *	RETVAL;
	dXSTARG;

        if ( sv_derived_from(ST(0), "CSS::Croco::Declaration") || sv_derived_from( ST(0),
            "CSS::Croco::DeclarationList" ))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            declaration = INT2PTR(CRDeclaration *, tmp);
          }
        else
          croak("declaration is not of type CSS::Croco::Declaration");

	if (items < 2)
	    value = NULL;
	else {
	    value = (char *)SvPV_nolen(ST(1));
	}
#line 201 "Croco.xs"
        if ( value ) {
            declaration->property = cr_string_new_from_string( value );
        }
        RETVAL = cr_string_dup2(declaration->property);
#line 584 "Croco.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__Declaration_value); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__Declaration_value)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "declaration, value = NULL");
    {
	CRDeclaration *	declaration;
	CRTerm*	value;
	SV *	RETVAL;

        if ( sv_derived_from(ST(0), "CSS::Croco::Declaration") || sv_derived_from( ST(0),
            "CSS::Croco::DeclarationList" ))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            declaration = INT2PTR(CRDeclaration *, tmp);
          }
        else
          croak("declaration is not of type CSS::Croco::Declaration");

	if (items < 2)
	    value = NULL;
	else {
	if (sv_derived_from(ST(1), "CSS::Croco::Term"))
	  {
	    IV tmp = SvIV((SV *) SvRV(ST(1)));
	    value = INT2PTR(CRTerm *, tmp);
	  }
	else
	  croak("value is not of type CSS::Croco::Term");
	}
#line 213 "Croco.xs"
        if ( value ) {
            declaration->value = value;
        }
        CRTerm* term = declaration->value;
        SV* rv = newSV(0);
        char* type;
        char base[] = "CSS::Croco::Term";
        switch ( term->type ) {
            case TERM_NO_TYPE:
                type = strdup("");
                break;
            case TERM_NUMBER:
                type = strdup("::Number");
                break;
            case TERM_FUNCTION:
                type = strdup("::Function");
                break;
            case TERM_STRING:
                type = strdup("::String");
                break;
            case TERM_IDENT:
                type = strdup("::Ident");
                break;
            case TERM_URI:
                type = strdup("::URI");
                break;
            case TERM_RGB:
                type = strdup("::RGB");
                break;
            case TERM_UNICODERANGE:
                type = strdup("::UnicodeRange");
                break;
            case TERM_HASH:
                type = strdup("::Hash");
                break;
            default:
                type = strdup("::Unknown");
        }
        sv_setref_pv(rv, strcat(base, type), (void*) term);
        RETVAL = rv;
#line 667 "Croco.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__Declaration_important); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__Declaration_important)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "declaration, value = NULL");
    {
	CRDeclaration *	declaration;
	SV*	value;
	bool	RETVAL;

        if ( sv_derived_from(ST(0), "CSS::Croco::Declaration") || sv_derived_from( ST(0),
            "CSS::Croco::DeclarationList" ))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            declaration = INT2PTR(CRDeclaration *, tmp);
          }
        else
          croak("declaration is not of type CSS::Croco::Declaration");

	if (items < 2)
	    value = NULL;
	else {
	    value = ST(1);
	}
#line 261 "Croco.xs"
        if ( value ) {
            declaration->important = SvIV(value);
        }
        RETVAL = declaration->important;
#line 709 "Croco.c"
	ST(0) = boolSV(RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__Declaration_next); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__Declaration_next)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "declaration");
    {
	CRDeclaration *	declaration;
	CRDeclaration *	RETVAL;

        if ( sv_derived_from(ST(0), "CSS::Croco::Declaration") || sv_derived_from( ST(0),
            "CSS::Croco::DeclarationList" ))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            declaration = INT2PTR(CRDeclaration *, tmp);
          }
        else
          croak("declaration is not of type CSS::Croco::Declaration");
#line 272 "Croco.xs"
        RETVAL = declaration->next;
#line 741 "Croco.c"
	ST(0) = sv_newmortal();
        sv_setref_pv(ST(0), "CSS::Croco::Declaration", (void*) RETVAL);
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__Declaration_prev); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__Declaration_prev)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "declaration");
    {
	CRDeclaration *	declaration;
	CRDeclaration *	RETVAL;

        if ( sv_derived_from(ST(0), "CSS::Croco::Declaration") || sv_derived_from( ST(0),
            "CSS::Croco::DeclarationList" ))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            declaration = INT2PTR(CRDeclaration *, tmp);
          }
        else
          croak("declaration is not of type CSS::Croco::Declaration");
#line 280 "Croco.xs"
        RETVAL = declaration->prev;
#line 773 "Croco.c"
	ST(0) = sv_newmortal();
        sv_setref_pv(ST(0), "CSS::Croco::Declaration", (void*) RETVAL);
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__Declaration_to_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__Declaration_to_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "declaration, indent = 0");
    {
	CRDeclaration *	declaration;
	long	indent;
	char *	RETVAL;
	dXSTARG;

        if ( sv_derived_from(ST(0), "CSS::Croco::Declaration") || sv_derived_from( ST(0),
            "CSS::Croco::DeclarationList" ))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            declaration = INT2PTR(CRDeclaration *, tmp);
          }
        else
          croak("declaration is not of type CSS::Croco::Declaration");

	if (items < 2)
	    indent = 0;
	else {
	    indent = (long)SvIV(ST(1));
	}
#line 289 "Croco.xs"
        RETVAL = cr_declaration_to_string( declaration, indent );
#line 813 "Croco.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_CSS__Croco__Term_to_string); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__Term_to_string)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "term");
    {
	CRTerm *	term;
	char *	RETVAL;
	dXSTARG;

        if (sv_derived_from(ST(0), "CSS::Croco::Term"))
          {
            IV tmp = SvIV((SV *) SvRV(ST(0)));
            term = INT2PTR(CRTerm *, tmp);
          }
        else
          croak("term is not of type CSS::Croco::Term");
#line 299 "Croco.xs"
        RETVAL = cr_term_to_string( term );
#line 844 "Croco.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


/* INCLUDE:  Including 'const-xs.inc' from 'Croco.xs' */


XS(XS_CSS__Croco__Term_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_CSS__Croco__Term_constant)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 4 "const-xs.inc"
#ifdef dXSTARG
	dXSTARG; /* Faster if we have it.  */
#else
	dTARGET;
#endif
	STRLEN		len;
        int		type;
	/* IV		iv;	Uncomment this if you need to return IVs */
	/* NV		nv;	Uncomment this if you need to return NVs */
	/* const char	*pv;	Uncomment this if you need to return PVs */
#line 878 "Croco.c"
	SV *	sv = ST(0);
	const char *	s = SvPV(sv, len);
#line 18 "const-xs.inc"
	type = constant(aTHX_ s, len);
      /* Return 1 or 2 items. First is error message, or undef if no error.
           Second, if present, is found value */
        switch (type) {
        case PERL_constant_NOTFOUND:
          sv =
	    sv_2mortal(newSVpvf("%s is not a valid CSS::Croco macro", s));
          PUSHs(sv);
          break;
        case PERL_constant_NOTDEF:
          sv = sv_2mortal(newSVpvf(
	    "Your vendor has not defined CSS::Croco macro %s, used",
				   s));
          PUSHs(sv);
          break;
	/* Uncomment this if you need to return IVs
        case PERL_constant_ISIV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHi(iv);
          break; */
	/* Uncomment this if you need to return NOs
        case PERL_constant_ISNO:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_no);
          break; */
	/* Uncomment this if you need to return NVs
        case PERL_constant_ISNV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHn(nv);
          break; */
	/* Uncomment this if you need to return PVs
        case PERL_constant_ISPV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, strlen(pv));
          break; */
	/* Uncomment this if you need to return PVNs
        case PERL_constant_ISPVN:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHp(pv, iv);
          break; */
	/* Uncomment this if you need to return SVs
        case PERL_constant_ISSV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(sv);
          break; */
	/* Uncomment this if you need to return UNDEFs
        case PERL_constant_ISUNDEF:
          break; */
	/* Uncomment this if you need to return UVs
        case PERL_constant_ISUV:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHu((UV)iv);
          break; */
	/* Uncomment this if you need to return YESs
        case PERL_constant_ISYES:
          EXTEND(SP, 1);
          PUSHs(&PL_sv_undef);
          PUSHs(&PL_sv_yes);
          break; */
        default:
          sv = sv_2mortal(newSVpvf(
	    "Unexpected return type %d while processing CSS::Croco macro %s, used",
               type, s));
          PUSHs(sv);
        }
#line 954 "Croco.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'Croco.xs' from 'const-xs.inc' */

#ifdef __cplusplus
extern "C"
#endif
XS(boot_CSS__Croco); /* prototype to pass -Wmissing-prototypes */
XS(boot_CSS__Croco)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    const char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("CSS::Croco::new", XS_CSS__Croco_new, file);
        newXS("CSS::Croco::parse", XS_CSS__Croco_parse, file);
        newXS("CSS::Croco::DESTROY", XS_CSS__Croco_DESTROY, file);
        newXS("CSS::Croco::StyleSheet::to_string", XS_CSS__Croco__StyleSheet_to_string, file);
        newXS("CSS::Croco::StyleSheet::rules", XS_CSS__Croco__StyleSheet_rules, file);
        newXS("CSS::Croco::StyleSheet::DESTROY", XS_CSS__Croco__StyleSheet_DESTROY, file);
        newXS("CSS::Croco::Statement::DESTROY", XS_CSS__Croco__Statement_DESTROY, file);
        newXS("CSS::Croco::Statement::RuleSet::get_declarations", XS_CSS__Croco__Statement__RuleSet_get_declarations, file);
        newXS("CSS::Croco::Statement::RuleSet::parse_declaration", XS_CSS__Croco__Statement__RuleSet_parse_declaration, file);
        newXS("CSS::Croco::DeclarationList::next", XS_CSS__Croco__DeclarationList_next, file);
        newXS("CSS::Croco::DeclarationList::parse", XS_CSS__Croco__DeclarationList_parse, file);
        newXS("CSS::Croco::DeclarationList::property", XS_CSS__Croco__DeclarationList_property, file);
        newXS("CSS::Croco::DeclarationList::to_string", XS_CSS__Croco__DeclarationList_to_string, file);
        newXS("CSS::Croco::DeclarationList::DESTROY", XS_CSS__Croco__DeclarationList_DESTROY, file);
        newXS("CSS::Croco::Declaration::property", XS_CSS__Croco__Declaration_property, file);
        newXS("CSS::Croco::Declaration::value", XS_CSS__Croco__Declaration_value, file);
        newXS("CSS::Croco::Declaration::important", XS_CSS__Croco__Declaration_important, file);
        newXS("CSS::Croco::Declaration::next", XS_CSS__Croco__Declaration_next, file);
        newXS("CSS::Croco::Declaration::prev", XS_CSS__Croco__Declaration_prev, file);
        newXS("CSS::Croco::Declaration::to_string", XS_CSS__Croco__Declaration_to_string, file);
        newXS("CSS::Croco::Term::to_string", XS_CSS__Croco__Term_to_string, file);
        newXS("CSS::Croco::Term::constant", XS_CSS__Croco__Term_constant, file);
    XSRETURN_YES;
}

